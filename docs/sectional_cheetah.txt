

SECTIONAL CHEETAH PARSING NOTES


Aim
- More accurately assign tool values
- Provide simplified pre/post tasks 
- Identify more tool arguments (resolve templated arguments) and update Command (edge case)

Approach
- Parse tool normally
- module runs when linking tool inputs to values
- module simplifies the <command> section using cheetah templating
- simplified <command> section is then used to identify values associated with arguments
    - can the argument be found in the simplified command? if so, determine its value
    - if not, it must be optional and in this case has a value of None
    - 
- what about the step inputs json? is this just ignored now? 




Cheetah templating
input dict
    - can't just slot in values 
        - need to determine the underlying param value  
        - "nogroup": "false" -> $nogroup is BoolToolParam. when value is false, value becomes ""
        - need to get the galaxy loaded gxparams, then evaluate the underlying value given the step value
process
    - left to right (indentation/cheetah constructs)
    - then top to bottom
    - so we don't have errors within construct, replace contents with identifier
    - after resolving the outer construct, replace the inner with the original text using the identifier
    - if error in outer construct resolution, keep going. its fine. 
    
    OUTER CONSTRUCT 

    #if $long                                       # OK
        #if $long.is_of_type('fastqsanger')         # FAILS (.is_of_type())
            #set lr = "lr.fastq"                    # OK
        #elif $long.is_of_type('fastqsanger.gz')    # FAILS (.is_of_type())
            #set lr = "lr.fastq.gz"                 # OK
        #elif $long.is_of_type('fasta')             # FAILS (.is_of_type())
            #set lr = "lr.fasta"                    # OK
        #end if                                     # OK
        ln -s '${long}' '$lr' &&                    # FAILS (no $lr)
    #else
        another command &&
    #end if
    
    
    
    
    
    
    
    
    
    
    
        another command &&
    

    BECOMES

    #if $long
        identifier1






        ln -s '${long}' '$lr' &&
    #else
        another command &&
    #end if

    #if $long
        identifier1






        identifier2
    #else
        identifier3
    #end if
    
    #if $long
        identifier1
        identifier2
    #else
        identifier3
    #end if

    identifier1 = """
        #if $long.is_of_type('fastqsanger')
            #set lr = "lr.fastq"
        #elif $long.is_of_type('fastqsanger.gz')
            #set lr = "lr.fastq.gz"
        #elif $long.is_of_type('fasta')
            #set lr = "lr.fasta"
        #end if
    """

    identifier2 = """
        ln -s '${long}' '$lr' &&
    """

    identifier3 = """
        another command &&
    """

    BECOMES

    
        identifier1






        identifier2
    
    
    

    BECOMES

        #if $long.is_of_type('fastqsanger')
            #set lr = "lr.fastq"
        #elif $long.is_of_type('fastqsanger.gz')
            #set lr = "lr.fastq.gz"
        #elif $long.is_of_type('fasta')
            #set lr = "lr.fasta"
        #end if
        ln -s '${long}' '$lr' &&

    INNER CONSTRUCT 1

        #if $long.is_of_type('fastqsanger')
            identifier1
        #elif $long.is_of_type('fastqsanger.gz')
            identifier2
        #elif $long.is_of_type('fasta')
            identifier3
        #end if

    identifier1 = """#set lr = "lr.fastq""""
    identifier2 = """#set lr = "lr.fastq.gz""""
    identifier3 = """#set lr = "lr.fasta""""

    BECOMES (due to failure)

        #if $long.is_of_type('fastqsanger')
            identifier1
        #elif $long.is_of_type('fastqsanger.gz')
            identifier2
        #elif $long.is_of_type('fasta')
            identifier3
        #end if
    
    BECOMES (back to a few steps ago as nothing to resolve)

        #if $long.is_of_type('fastqsanger')
            #set lr = "lr.fastq"
        #elif $long.is_of_type('fastqsanger.gz')
            #set lr = "lr.fastq.gz"
        #elif $long.is_of_type('fasta')
            #set lr = "lr.fasta"
        #end if

    INNER CONSTRUCT 2

        ln -s '${long}' '$lr' &&
    
    BECOMES

        ln -s '${long}' '$lr' && (failure)
    
    FINAL 

        #if $long.is_of_type('fastqsanger')
            #set lr = "lr.fastq"
        #elif $long.is_of_type('fastqsanger.gz')
            #set lr = "lr.fastq.gz"
        #elif $long.is_of_type('fasta')
            #set lr = "lr.fasta"
        #end if
        ln -s '${long}' '$lr' &&













Templated tool arguments (9+ tools)
    gatk2_macros.xml
    #if hasattr( $param.input, 'truevalue' ):
        ${param}
    #else:
        --${name} "${param}"
    #end if

    nanoplot.xml
    --$mode.reads.type ${' '.join($reads_temp)}

    metaspades.xml
    --$prefix$num-1 fastq:$file.file_type.fwd_reads

    mitos2.xml
    --$tpe 0


moving main python to pretask 
    - swap __FUNCTION_CALL__ with $env_var
    - creat #set env_var = __FUNCTION_CALL__ line at end of pre-task
        --$mode.reads.type ${' '.join($reads_temp)}
        --fastq ${' '.join($reads_temp)} [after cheetah simplification - step input mode.reads.type]

        [PRETASK]
        #set mode_reads_type = ${' '.join($reads_temp)}
        [MAIN]
        --$mode.reads.type $mode_reads_type
        --fastq input1.fq input2.fq 

        w.input(
            'nanoplot',
            NanoPlot(
                mode_reads_type=nanoplot_pretask_mode_reads_type,   # 
            )
    



improvements to FASTQC
(alias, not cheetah)
ln -s '${input_file}' '${input_file_sl}' &&
    - ${input_file} -> ${input_file_sl}
    - (gxparam) is aliased to (env var)

improvements to UNICYCLER
    w.in_forward_reads goes where?
    fastq_input1=w.in_forward_reads,          # -1 [FastqSanger]
    option_s=w.in_forward_reads,              # -s [FastqSanger]

relevant cheetah:
    #if str( $paired_unpaired.fastq_input_selector ) == "paired"
        -1 '$fq1'
    #elif str( $paired_unpaired.fastq_input_selector ) == "paired_collection"
        -1 '$fq1'
    #elif str( $paired_unpaired.fastq_input_selector ) == "single"
        -s '$fq'

relevant step inputs: 
    $paired_unpaired.fastq_input_selector = 'paired'

would resolve the above. <command> would be templated to:
    -1 '$fq1'
therefore we have 
    fastq_input1=w.in_forward_reads,    # -1 [FastqSanger]
    option_s=None,                      # -s [FastqSanger] [IMPROVEMENT]

some other inputs may be wrong values? and these could also be template to correct value. especially for cases where we are checking condition

improvements to MULTIQC


   
fastp templating

```
fastp

--thread \${GALAXY_SLOTS:-1}
--report_title 'fastp report for $in1_name' [NOT TEMPLATABLE till runtime]

#if $in1.is_of_type('fastqillumina', 'fastqsolexa', 'fastqillumina.gz', 'fastqsolexa.gz'): [NOT TEMPLATABLE till runtime]
    --phred64
#end if

-i '$in1_name' [NOT TEMPLATABLE till runtime]
-o first${ext} [DEFAULT TEMPLATABLE]

#if str($single_paired.single_paired_selector).startswith('paired'): [DEFAULT TEMPLATABLE]
    -I '$in2_name'  [NOT TEMPLATABLE till runtime]
    -O second${ext} [DEFAULT TEMPLATABLE]
#end if
```






    - xml <command> will always be parsed to identify tool inputs
        - tests provide evaulated command strings, while xml does not
    - tool inputs are enclosed within cheetah control logic 
    - tool inputs may have an env var for its value 
    - <command> section may include arbitrary python code which needs to be evaluated to get a final value


Motivation: Control logic
    - conditional / loops
    - don't know whether they should appear in the command (conditional block), or their value (loops)
    
    #if 'json_stats' in $output_selector:
        --json stats.json
    #end if


Motivation: Env var for tool input value
    - set using cheetah / python code
    - can't get the underlying value until cheetah evaulation

    #if $filter.readtype
        --readtype $filter.readtype  (gxparam)
    #end if
    
    #set out1 = $output_paired_coll.forward (env var from gxparam value)

    -x '$index_path'  (env var)


Motivation: Arbitrary python
    - python can appear anywhere and is executed as part of cheetah evaluation
    - this is commonly text manipulation, and can occur inline, or when setting env vars

    #set $in1_name = re.sub('[^\w\-\s]', '_', str($single_paired.paired_input.name)) + $ext
    solution: 
        - gather all enclosing lines referencing $in1_name
        - evaluate all
        - replace lines with evaluated lines

    ```
    #if $single_paired.single_paired_selector == 'paired_collection':
        #set $in1_name = re.sub('[^\w\-\s]', '_', str($single_paired.paired_input.name)) + $ext
        ln -s '$in1' '$in1_name' &&
    #else
        #set $in1_name = re.sub('[^\w\-\s]', '_', str($in1.element_identifier)) + $ext
        ln -s '$in1' '$in1_name' &&
    #end if
    --report_title 'fastp report for $in1_name'
    -i '$in1_name'
    ```

    ```
    #if $one_header:
      #if $filename.add_name:
        awk '{if (NR==1) {print "Sample\t"$0}}' "$input_list[0]";
      #else:
        awk '{if (NR==1) {print}}' "$input_list[0]";
      #end if
    #end if
    ```

    --$mode.reads.type ${' '.join($reads_temp)}
    solution: evaluate line to create simplified version


Requirements
- 


Structure of workflow steps
- pre-task
- main
- post-task





Outcomes of cheetah section evaulation:
- valid evaluation: tool input / value are present (linkable: value is value)
- valid evaluation: tool input / value are not present (linkable: value is None)
- invalid evaluation: execution fails (not linkable)


naive is to just grab enclosing cheetah around each reference to the input argument:

#if 'json_stats' in $output_selector:
    --json stats.json
#end if

doesn't work in this situation, as other env vars are definied in the header 





