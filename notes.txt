



Command parsing

what is the main goal here? 

 - identify the base command word
 - positional arguments
 - prefixed arguments
 - optional arguments?
 - aliases (through #set directives, #def function directives)

for each argument, want to identify all the params which can set the arg
take an approach more focused on the command text rather than locating galaxy params

to add: 
 - sometimes no ' ', '=', ':' between arg and value. ie head -n1. almost always an integer? 

positional arguments
 - keep track of whether each argument has a prefix or not
 - keep track of the 'position' of each argument.  is this each word? each argument? (ie key: val arg pair)





Datatypes 

UnionType 
 - never used
 - single datatype is selected instead 

Optional
 - if optional="true" in param
 - if appears only in conditional line
 - need to add in conditional block

Array
 - only if 
    - data_collection param
    - data param with multiple="True"
    - collection output
    - output with '*' or '.+' in 'pattern'











known limitations:

ignoring param.name is not unique 
    ie param1.name = param2.name but param1.gx_var != param2.gx_var

ignored complex or rare features 
    data->change_format
    data->actions
    data->default_identifier_source
    discover_datasets->recurse

for loops over array variables ignored
    #for $bed in $names.beds:
        '${bed.input}'
    #end for 

should I have a list of unhandled scenarios for runtime warnings? yes.





future features:
 - positional arguments
 - #set directives
 - global macros, tokens and set directives
 - cheetah function parsing -> temp vars 
 - DataCollectionParam, DataColumnParam, HiddenParam parsing
 - <repeat> tag 
 - <options> tag 