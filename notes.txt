


Classes

ToolParser
 - Overall orchestrator


XMLParser
 - Parses XML file
 - 


MacroParser

 - Explores xml trees with tag in ['tool', 'macros', 'xml']
 - Notes relevant data
 - Finds relevant subtags
 - sends the xml tree at the subtag to relevant tag parser
 - creates objects for relevant tags (with local 'paths')
 - has local depth pointer


ParamParser
 - parses params 
 - identifies name, default value, type, helptext 


TokenExpander
 - not sure if single post-processing step, or each XMLParser should do


CommandParser
 - identifies base command 
 - identifies each known param
 - augments known param information to include:
    - position = inp.position,
    - prefix = inp.prefix,
    - separate_value_from_prefix = inp.is_prefix_separated,
    - prefix_applies_to_all_elements = inp.is_array,
    - shell_quote = inp.should_quote,
    - separator = inp.separator,
    - localise_file = inp.should_localise,



Each XMl may have 1 or more <xml> tags
Each XML has tokens - are these global to whole tool? Assume so. 
An imported XML can itself have imports 
An XML macro can itself have internal XML macros 


Macros 
- Always contained in <macros>
- Individual macros marked with 'xml' or 'macro' tag
- Imports always found with <macros> tag
- Yield and tokens can be used to inject xml / template macros
- only 1st level tags allowed inside <macros> are import, token, macro, xml

token example 

macro def:
<macros>
  <xml name="color" token_varname="myvar" token_default_color="#00ff00" token_label="Pick a color">
      <param name="@VARNAME@" type="color" label="@LABEL@" value="@DEFAULT_COLOR@" />
  </xml>
</macros>

referencing macro with params:
<inputs>
    <expand macro="color" default_color="#ff0000" />
    <expand macro="color" default_color="#0000ff" varname="c2" label="Choose a different color" />
</inputs>

output xml:
<inputs>
    <param name="myvar" type="color" label="Pick a color" value="#ff0000" />
    <param name="c2" type="color" label="Choose a different color" value="#0000ff" />
</inputs>



Yield example:

<xml/macro name="mymacro">
  <param name="index" type="select" label="Select a reference genome">

    <yield />  <!-- will be replaced -->

  </param>
</xml/macro>

when called with:
<expand macro="mymacro">

  <!-- this will replace yield -->
  <options from_data_table="tophat_indexes">
    <filter type="sort_by" column="2"/>
    <validator type="no_options" message="No genomes are available for the selected input dataset"/>
  </options>

</expand>

would become:
<param name="index" type="select" label="Select a reference genome">

  <!-- yield has been replaced: -->
  <options from_data_table="tophat_indexes">
    <filter type="sort_by" column="2"/>
    <validator type="no_options" message="No genomes are available for the selected input dataset"/>
  </options>

</param>























Goals
    - Extract
        - tool metadata (for CommandToolbuilder)
        - cli command (for CommandToolbuilder)
        - inputs ('params' tag)
        - outputs ('data' tag)
        - tests 
    - Process tokens
    - Expand macros
    - Format to janis

Process:
    1. Parse
        - Gather imported files
        - For each imported file:
            - consume xml
            - expand 


functions needed:
    parse tool (top level)
    parse xml (parses individual 'xml' sections)
    parse param (parses 'param' tags dependent on internals)
    parse data (parses 'data' tags dependent on internals)
    parse tokens (parses 'token' tags)
    expand macros (injects xml as child element with correct heirarchy)
    expand tokens (replaces tokens with values)





tags needed:
  - description (tool description)
  - macros (xml sections)
  - creator (author)
  - requirements (conda packages or containers)
  - command (cli command)
  - configfiles (don't parse body, use like param)
  - inputs (extract the params)
    - param
  - outputs (extract the data outputs)
    - data
  - tests
  - help
  - citations


CommandToolbuilder
metadata:
    - tool (tag=tool, tool name)
    - tool_module = 'bioinformatics' 
    - tool_provider (tag=citations->citation, author)
    - version (tag=tool)
    - container (tag=requirements->requirement. if exists. ignore requirement:'packages')

command:
    - base_command
    - arguments (used to generate command line)
    - cpu (either as param or hard set in command)
    - memory (either as param or hard set in command)
    - time (either as param or hard set in command)
    - disk (either as param or hard set in command)
    - directories_to_create
    - files_to_create

other
    - inputs
    - outputs

ToolInput
    - inp.name,
    - inp.type,
    - position = inp.position,
    - prefix = inp.prefix,
    - separate_value_from_prefix = inp.is_prefix_separated,
    - prefix_applies_to_all_elements = inp.is_array,
    - shell_quote = inp.should_quote,
    - separator = inp.separator,
    - localise_file = inp.should_localise,
    - default = inp.default,
    - doc = inp.help,

ToolOutput
    - out.name,
    - out.type,
    - selector,
    - doc



milestones
 - 


root tag = 'tool'

Relevant top level items:
  - description (tool description)
  - macros (xml sections)
  - creator (author)
  - requirements (conda packages or containers)
  - code (ignored)
  - stdio (ignored)
  - version_command (ignored)
  - command (cli command)
  - configfiles (don't parse body, use like param)
  - inputs (extract the params)
  - outputs (extract the data outputs)
  - tests
  - help
  - citations

2nd level (these can occur at any level within the top-level item)
inputs
  section
  repeat
  conditional
    - when
  param
    - validator
    - option
    - conversion
    - options 
    - sanitizer

outputs 
  data
    - filter
    - change_format
    - actions
    - discover_datasets
  collection
    - filter
    - discover_datasets

