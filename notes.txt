

current errors:

no container
allegro
art tools
bayescan

silent
augustus tools
bamutil clip_overlap

python err 
multiple expanded forms of cmd word
IndexError tokens = self.get_all_tokens(word.expanded_text[0])



clip_overlap.xml
basil.xml



v0.1 supported -------------------------------------------------------------------



v0.1 unsupported -----------------------------------------------------------------

- general
    - different versions of same tool
        - container cache is holding version number at least 

- command string
    - \$_GALAXY_JOB_TMP_DIR (no idea what to do)
    - for loops
    - multiline bash blocks
    - MULTIPLE EXPANDED FORMS (filtlong) why?
    - Multiline strings
        #if $lib_repeat
            lib='
            #for $i in range(len($lib_repeat))
                lib$i
            #end for
            '
    - INDICIES (bwa-mem)
    - -o first${ext}
    - proper reconstruction of command order using cheetah command logic
    - tools with multiple commands (only first is interpreted at the moment) (bwa.xml is good example)
        - do I need to consider '&&' after the first '>' / '|' ? 

- param features 
    - non-unique param / output names 
        - ie param1.name = param2.name but param1.gx_var !=
          param2.gx_var
    - builtin datasets
    - repeat tags
    - ignored complex or rare features 
        - data->change_format
        - data->actions
        - data->default_identifier_source
        - discover_datasets->recurse
    - tools with multiple commands
        - each '|' or '&&' or ';' could represent a different command that could be run as a step
        - in these cases, the single tool xml can be split into multiple janis tool definitions
        - first, split the command string into each individual command
        - identify the particular command which seems to be main one (ie bwa in bwa.xml, even though it has a number of samtools commands)
        - when executing workflows, it could be known that the tool xml was split into (4) janis tools
        - the step could then run as sort-of a sub-workflow
        - when splitting a tool xml into multiple tool definitions: 
            - first check if a tool def exists 
            - if so, add any newly discovered params / outputs / command components
            - else, just create a new one from scratch
            - this approach is already employed by the main workflow specs incl janis. 
            - sometimes even something simple like 'tr a-z A-Z < file.txt' is run as an individual step in a vanilla ubuntu container


General Notes --------------------------------------------------------------------

- tool versions
    - the version in the tool xml may not actually be the same as the requirement
    - merely represents the information in the wrapper, not the actual version of the tool that the container executes
    - 

- tool name
    - both the tool_id and tool_name in the xml are unreliable.
    - tool name is taken as tool_id.replace('-', '_').lower()
    - this isn't necessarily the same name as the main requirement being executed
    - again, simply gives a reasonable name specified from the tool xml
    - this allows us to then parse gx workflows and actually understand what tool definition the janis should load. 





end ------------------------------------------------------------------------------



SUPPORTED REDIRECTION
0 is stdin, 1 is stdout, and 2 is stderr
'&amp;' is also accepted as '&'
'>>' is also accepted as '>'

STDOUT to file (often used for outputs) (337 tools)
    construct           > file
    galaxy occurance    > '$report'   (report has format="tabular")
    janis solution      ToolOutput("report", Tabular, Stdout(optional=False))

STDERR to file (4 tools)
    construct           2>&1 > file
    galaxy occurance    2>&1 > $file_stderr
    janis solution      ToolOutput("file_stderr", Textfile, Stdout(optional=False))

branch/split STDOUT to a file (usually for logs) (142 tools)
    construct           | tee file
    galaxy occurance    '$out_result' | tee '$out_log'  (out_log has format="txt")
    janis solution      ToolOutput("report", Textfile, Stdout(optional=False))
    
    does janis support this? 
        - should be fine in situations where '| tee' effectively replaces '>'
        - ie when whatever gets passed to '| tee' is the final stdout of the tool step
        - what if the tool continues and performs other actions? then goes on to collect stdout at a later time point? 

branch/split STDERR & STDOUT to a file (usually for logs) (3 tools)
    construct           |& tee file (short for `2>&1 | tee file`)
    galaxy occurance    --verbose 3 |& tee '$out_log'
    janis solution      ToolOutput("out_log", Datatype, Stdout(optional=False))

STDIN
    construct           < infile
    galaxy occurance    datamash reverse < $in_file > $out_file
    janis solution      ToolInput("in_file", Datatype, prefix="<" etc)

STDOUT to STDERR (4 tools)
    construct           1>&2 
    galaxy occurance    echo "Reporting ... single input sample" 1>&2; exit 1 
    janis solution      ignore. handled by workflow manager 

STDERR to STDOUT (50 tools)
    construct           2>&1
    galaxy occurance    '$inputfile' '$output' 2>&1
    janis solution      ignore. handled by workflow manager 

something to STDERR (usually a quoted string or logfile) (19 tools)
    construct           >&2
    galaxy occurance    >&2 "unknown extension $in.input.ext"
    janis solution      ignore. handled by workflow manager 


Note
If |& is used, the standard error of command is connected to command2â€™s standard input through the pipe; it is shorthand for 2>&1 |
    |& tee -a '$out_log'
    2>&1 | tee -a '$out_log'

Bin something
    /dev/null


Params
    the galaxy params are more like suggestions than rules
    galaxy params should be parsed as-is
    at postprocessing stage should be remapped into final understanding of underlying tool


AT postprocess stage
    bool params:
        - truevalue and falsevalue are 


from non-galaxy command string
--augustus=true

have a registry
know that
    --augustus=true is key-val pair
    --augustus= can be set from $use_augustus boolean gx param
    can simply look at $use_augustus and confirm that either truevalue or falsevalue == '--augustus=true'
    can then set that attribute when translating external -> galaxy 


SELECT PARAMS

list of flags (one may be blank)

    (bedtools bamtobed)
    <option value="">Create a 6-column BED file</option>
    <option value="-bed12">Create a full, 12-column "blocked" BED  file</option>
    <option value="-bedpe">Create a paired-end, BEDPE format</option>

list of options

    (bedtools genomecoveragebed)
    <option value="">both strands combined</option>
    <option value="-strand +">positive strand only</option>
    <option value="-strand -">negative strand only</option>

list of kv pairs

    (lastz)
    <option value="--strand=both" selected="True">Both</option>
    <option value="--strand=plus">Plus</option>
    <option value="--strand=minus">Minus</option>

a blend

    (lastz)
    <option value="--transition" selected="true">One</option>
    <option value="--transition=2">Two</option>
    <option value="--notransition">None</option>


if the param is select
    check that each option is "" or starts with "-"
    if true:
        inject all the options directly into the list of command words





BOOLEAN PARAMS

SINGLE VALUE

single value but its assigned to falsevalue

    (mothur pairwise.seqs)
    truevalue="" falsevalue="countends=false," 

single value and its spaced kv pair 
NOTE: this is for a configfile! 

    (circos macros)
    truevalue="flow = continue"
    falsevalue=""


TWO DIFFERENT VALUES

    (allegro)
    truevalue="on"
    falsevalue="off"

    (bcftools_query)
    truevalue="True"
    falsevalue="False"

    (art/macros)
    truevalue="centimorgan"
    falsevalue="recombination"

    (augustus)
    truevalue="1"
    falsevalue="0" 

involving flags

    (kofamscan)
    truevalue="--report-unannotated"
    falsevalue="--no-report-unannotated" 

kv_pairs yes/no

    (minimap2)
    truevalue="--splice-flank=yes" 
    falsevalue="--splice-flank=no" 

single option, two values

    (velvetg)
    truevalue="-read_trkg yes" 
    falsevalue="-read_trkg no"




skip conditions
at least 1 of [truevalue, falsevalue] == ""

else
expand every option (select param), truevalue/falsevalue and try to interpret as 









flag-list select params:



Richard:
    - how do you want to handle select params encompassing multiple flags?


Tools with unsupported features

For loops
    - genetrack
    - annotateBed


cutadapt generally super fucked

Macro parsing not working as expected! Fastp




Current thoughts:
- optionality for arguments is not possible to identify. can supply defaults in most cases as workaround. 


Command parsing
    - #include not supported
    - multiline bash blocks not supported (about 12 tools)
    - currently throwing out bash conditionals
    - should add bash aliases - 'export AUGUSTUS_CONFIG_PATH=`pwd`/augustus_dir/'


Non-supported features
    - for loop statements
    - aliases with anything except '#set x = y' structure


What the hell is bcftools_cnv.xml doing with mv $outputs? 

Command parsing

what is the main goal here? 
- options (and their arguments)
- identify the base command word
- positional arguments

   

COMMAND DATASTRUCTURES

aliases
{
    source [str]:    alias [Alias]
                    {
                        alias.source: str
                        alias.dest: str
                        alias.text: str
                        alias.instruction: str
                    }
}

env_vars - list of strings (each string is varname)
{
    '$AUGUSTUS_CONFIG_PATH',
}

params - gx_var is stripped to minimal form: $var
{
    param.gx_var [str]: param [Param]
                        {
                            param.name: str
                            param.gx_var: str
                            param.janis_var: str
                            param.galaxy_type: str
                        }
}

command_words
[
    cmdword [CommandWord]
    {
        cmdword.text = text
        cmdword.command_num = command_num
        cmdword.in_loop = False
        cmdword.in_conditional = False
    },

    
]








Datatypes 

UnionType 
 - never used
 - single datatype is selected instead 

Optional
 - if optional="true" in param
 - if appears only in conditional line
 - need to add in conditional block

Array
 - only if 
    - data_collection param
    - data param with multiple="True"
    - collection output
    - output with '*' or '.+' in 'pattern'












should I have a list of unhandled scenarios for runtime warnings? yes.

