<tool id="bwa_mem" name="Map with BWA-MEM" version="0.7.17.2">
    <description>- map medium and long reads (&gt; 100 bp) against reference genome</description>
    <macros>
        <import>read_group_macros.xml</import>
        <import>bwa_macros.xml</import>
    </macros>
    <requirements>
            <requirement type="package" version="0.7.17">bwa</requirement>
            <requirement type="package" version="1.6">samtools</requirement>
        </requirements>
    <stdio>
            <exit_code range="1:" />
            <exit_code range=":-1" />
            <regex match="Error:" />
            <regex match="Exception:" />
            <regex match="\[bns_restore_core\] Parse error reading" />
        </stdio>
    <command>
set -o | grep -q pipefail &amp;&amp; set -o pipefail;

    #if str( $reference_source.reference_source_selector ) == "history":
        #set $reference_fasta_filename = "localref.fa"
        ln -s '${reference_source.ref_file}' '${reference_fasta_filename}' &amp;&amp;
        bwa index
        #if str($reference_source.index_a) != 'auto'
            -a ${reference_source.index_a}
        #end if
        '${reference_fasta_filename}' &amp;&amp;
    #else:
        #set $reference_fasta_filename = str( $reference_source.ref_file.fields.path )
    #end if
  

## Begin BWA-MEM command line

bwa mem

#if str( $output_sort ) == "unsorted":
    -t 1
#else
    -t "\${GALAXY_SLOTS:-1}"
#end if
## Verbosity is set to 1 (errors only)
-v 1

#if str( $fastq_input.fastq_input_selector ) == "paired_iv":
    ## For interleaved fastq files set -p option
    -p
    ## check that insert statistics is used
    #if str( $fastq_input.iset_stats ):
      -I '${fastq_input.iset_stats}'
    #end if
#end if

#if str( $analysis_type.analysis_type_selector ) not in ["illumina", "full"]:
    -x '$analysis_type.analysis_type_selector'
#elif str( $analysis_type.analysis_type_selector ) == "full":
    ## Algorithmic options
    #if str( $analysis_type.algorithmic_options.algorithmic_options_selector ) == "set":
        -k '${analysis_type.algorithmic_options.k}'
        -w '${analysis_type.algorithmic_options.w}'
        -d '${analysis_type.algorithmic_options.d}'
        -r '${analysis_type.algorithmic_options.r}'
        -y '${analysis_type.algorithmic_options.y}'
        -c '${analysis_type.algorithmic_options.c}'
        -D '${analysis_type.algorithmic_options.D}'
        -W '${analysis_type.algorithmic_options.W}'
        -m '${analysis_type.algorithmic_options.m}'
        ${analysis_type.algorithmic_options.S}
        ${analysis_type.algorithmic_options.P}
        ${analysis_type.algorithmic_options.e}
    #end if

    ## Scoring options
    #if str( $analysis_type.scoring_options.scoring_options_selector ) == "set":
        -A '${analysis_type.scoring_options.A}'
        -B '${analysis_type.scoring_options.B}'
        -O '${analysis_type.scoring_options.O}'
        -E '${analysis_type.scoring_options.E}'
        -L '${analysis_type.scoring_options.L}'
        -U '${analysis_type.scoring_options.U}'
    #end if

    ## IO options
    #if str( $analysis_type.io_options.io_options_selector ) == "set":
        -T '${analysis_type.io_options.T}'
        -h '${analysis_type.io_options.h}'
        ${analysis_type.io_options.a}
        ${analysis_type.io_options.C}
        ${analysis_type.io_options.V}
        ${analysis_type.io_options.Y}
        ${analysis_type.io_options.M}
        ${analysis_type.io_options.five}
        ${analysis_type.io_options.q}
    #end if

#end if

## Handle read group options...

#def identifier_or_name($input1)
    #if hasattr($input1, 'element_identifier')
        #return $input1.element_identifier
    #else
        #return $input1.name.rstrip('.gz').rstrip('.fastq').rstrip('.fq')
    #end if
#end def

#def clean(name)
    #import re
    #set $name_clean = re.sub('[^\w\-_\.]', '_', $name)
    #return $name_clean
#end def

#def read_group_name_default($input1, $input2=None)
    #if $input2 is None
        #return $clean($identifier_or_name($input1))
    #else
        #import itertools
        #set $input_name1 = $clean($identifier_or_name($input1))
        #set $input_name2 = $clean($identifier_or_name($input2))
        #set $common_prefix = ''.join([c[0] for c in itertools.takewhile(lambda x: all(x[0] == y for y in x), itertools.izip(*[$input_name1, $input_name2]))])
        #if len($common_prefix) &gt; 3
            #return $common_prefix
        #else
            #return $input_name1
        #end if
    #end if
#end def

#def format_read_group(prefix, value, quote='', arg='')
    #if $value
        #return $arg + $quote + $prefix + $value + $quote
    #else
        #return ''
    #end if
#end def

#def rg_param(name)
    #if $varExists("rg")
        #return $rg.get($name, None)
    #else
        #return $getVar($name, None)
    #end if
#end def

#set $use_rg = True
    
#if str( $fastq_input.fastq_input_selector ) == "paired":
    #set $rg_auto_name = $read_group_name_default($fastq_input.fastq_input1, $fastq_input.fastq_input2)
#else:
    #set $rg_auto_name = $read_group_name_default($fastq_input.fastq_input1)
#end if

#set $use_rg = str($rg.rg_selector) != "do_not_set"
    

#if $use_rg
    #if $rg_param('read_group_id_conditional') is None
        #set $rg_id = $rg_auto_name
    #elif $rg_param('read_group_id_conditional').do_auto_name
        #set $rg_id = $rg_auto_name
    #else
        #set $rg_id = str($rg_param('read_group_id_conditional').ID)
    #end if

    #if $rg_param('read_group_sm_conditional') is None
        #set $rg_sm = ''
    #elif $rg_param('read_group_sm_conditional').do_auto_name
        #set $rg_sm = $rg_auto_name
    #else
        #set $rg_sm = str($rg_param('read_group_sm_conditional').SM)
    #end if

    #if $rg_param('PL')
        #set $rg_pl = str($rg_param('PL'))
    #else
        #set $rg_pl = ''
    #end if

    #if $rg_param('read_group_lb_conditional') is None
        #set $rg_lb = ''
    #elif $rg_param('read_group_lb_conditional').do_auto_name
        #set $rg_lb = $rg_auto_name
    #else
        #set $rg_lb = str($rg_param('read_group_lb_conditional').LB)
    #end if

    #if $rg_param('CN')
        #set $rg_cn = str($rg_param('CN'))
    #else
        #set $rg_cn = ''
    #end if

    #if $rg_param("DS")
        #set $rg_ds = str($rg_param("DS"))
    #else
        #set $rg_ds = ''
    #end if

    #if $rg_param("DT")
        #set $rg_dt = str($rg_param("DT"))
    #else
        #set $rg_dt = ''
    #end if

    #if $rg_param("FO")
        #set $rg_fo = str($rg_param("FO"))
    #else
        #set $rg_fo = ''
    #end if

    #if $rg_param("KS")
        #set $rg_ks = str($rg_param("KS"))
    #else
        #set $rg_ks = ''
    #end if

    #if $rg_param("PG")
        #set $rg_pg = str($rg_param("PG"))
    #else
        #set $rg_pg = ''
    #end if

    #if $rg_param("PI") != None
        #set $rg_pi = str($rg_param("PI"))
    #else
        #set $rg_pi = ''
    #end if

    #if $rg_param("PU")
        #set $rg_pu = str($rg_param("PU"))
    #else
        #set $rg_pu = ''
    #end if
#end if
    
#if $use_rg
    
        #set $rg_string = "@RG\\tID:" + str($rg_id)
        #set $rg_string += $format_read_group("\\tSM:", $rg_sm)
        #set $rg_string += $format_read_group("\\tPL:", $rg_pl)
        #set $rg_string += $format_read_group("\\tLB:", $rg_lb)
        #set $rg_string += $format_read_group("\\tCN:", $rg_cn)
        #set $rg_string += $format_read_group("\\tDS:", $rg_ds)
        #set $rg_string += $format_read_group("\\tDT:", $rg_dt)
        #set $rg_string += $format_read_group("\\tFO:", $rg_fo)
        #set $rg_string += $format_read_group("\\tKS:", $rg_ks)
        #set $rg_string += $format_read_group("\\tPG:", $rg_pg)
        #set $rg_string += $format_read_group("\\tPI:", $rg_pi)
        #set $rg_string += $format_read_group("\\tPU:", $rg_pu)
    
    -R '$rg_string'
#end if

#if str( $fastq_input.fastq_input_selector ) == "paired":
    ## check that insert statistics is used
    #if str( $fastq_input.iset_stats ):
        -I '${fastq_input.iset_stats}'
    #end if

    '${reference_fasta_filename}'
    '${fastq_input.fastq_input1}' '${fastq_input.fastq_input2}'
#elif str( $fastq_input.fastq_input_selector ) == "paired_collection":
    ## check that insert statistics is used
    #if str( $fastq_input.iset_stats ):
        -I '${fastq_input.iset_stats}'
    #end if

    '${reference_fasta_filename}'
    '${fastq_input.fastq_input1.forward}' '${fastq_input.fastq_input1.reverse}'
#else:
    '${reference_fasta_filename}'
    '${fastq_input.fastq_input1}'
#end if

#if str( $output_sort ) == "coordinate":
        | samtools sort -@\${GALAXY_SLOTS:-2} -T "\${TMPDIR:-.}" -O bam -o '$bam_output'
#elif str( $output_sort ) == "name":
        | samtools sort -n -@\${GALAXY_SLOTS:-2} -T "\${TMPDIR:-.}" -O bam -o '$bam_output'
#else
        | samtools view -@ \${GALAXY_SLOTS:-2} -bS - -o '$bam_output'
#end if


    </command>

    <inputs>
        <conditional name="reference_source">
            <param name="reference_source_selector" type="select" label="Will you select a reference genome from your history or use a built-in index?" help="Built-ins were indexed using default options. See `Indexes` section of help below">
                <option value="cached">Use a built-in genome index</option>
                <option value="history">Use a genome from history and build index</option>
            </param>
            <when value="cached">
                <param name="ref_file" type="select" label="Using reference genome" help="Select genome from the list">
                    <options from_data_table="bwa_mem_indexes">
                        <filter type="sort_by" column="2" />
                        <validator type="no_options" message="No indexes are available" />
                    </options>
                    <validator type="no_options" message="A built-in reference genome is not available for the build associated with the selected input file" />
                </param>
            </when>
            <when value="history">
                <param name="ref_file" type="data" format="fasta" label="Use the following dataset as the reference sequence" help="You can upload a FASTA sequence to the history and use it as reference" />
                <param name="index_a" type="select" label="Algorithm for constructing the BWT index" help="(-a)">
                    <option value="auto">Auto. Let BWA decide the best algorithm to use</option>
                    <option value="is">IS linear-time algorithm for constructing suffix array. It requires 5.37N memory where N is the size of the database. IS is moderately fast, but does not work with database larger than 2GB</option>
                    <option value="bwtsw">BWT-SW algorithm. This method works also with big genomes</option>
                </param>
            </when>
        </conditional>
    <conditional name="fastq_input">
            <param name="fastq_input_selector" type="select" label="Single or Paired-end reads" help="Select between paired and single end data">
                <option value="paired">Paired</option>
                <option value="single">Single</option>
                <option value="paired_collection">Paired Collection</option>
                <option value="paired_iv">Paired Interleaved</option>
            </param>
            <when value="paired">
                <param name="fastq_input1" type="data" format="fastqsanger,fastqsanger.gz,fasta" label="Select first set of reads" help="Specify dataset with forward reads" />
                <param name="fastq_input2" type="data" format="fastqsanger,fastqsanger.gz,fasta" label="Select second set of reads" help="Specify dataset with reverse reads" />
                <param name="iset_stats" type="text" optional="True" label="Enter mean, standard deviation, max, and min for insert lengths." help="-I; This parameter is only used for paired reads. Only mean is required while sd, max, and min will be inferred. Examples: both &quot;250&quot; and &quot;250,25&quot; will work while &quot;250,,10&quot; will not. See below for details.">
                    <sanitizer invalid_char="">
                        <valid initial="string.digits"><add value="," /> </valid>
                    </sanitizer>
                </param>
            </when>
            <when value="single">
                <param name="fastq_input1" type="data" format="fastqsanger,fastqsanger.gz,fasta" label="Select fastq dataset" help="Specify dataset with single reads" />
            </when>
            <when value="paired_collection">
                <param name="fastq_input1" format="fastqsanger,fastqsanger.gz,fasta" type="data_collection" collection_type="paired" label="Select a paired collection" help="See help section for an explanation of dataset collections" />
                <param name="iset_stats" type="text" optional="True" label="Enter mean, standard deviation, max, and min for insert lengths." help="-I; This parameter is only used for paired reads. Only mean is required while sd, max, and min will be inferred. Examples: both &quot;250&quot; and &quot;250,25&quot; will work while &quot;250,,10&quot; will not. See below for details.">
                    <sanitizer invalid_char="">
                        <valid initial="string.digits"><add value="," /> </valid>
                    </sanitizer>
                </param>
            </when>
            <when value="paired_iv">
                <param name="fastq_input1" type="data" format="fastqsanger,fastqsanger.gz,fasta" label="Select fastq dataset" help="Specify dataset with interleaved reads" />
                <param name="iset_stats" type="text" optional="True" label="Enter mean, standard deviation, max, and min for insert lengths." help="-I; This parameter is only used for paired reads. Only mean is required while sd, max, and min will be inferred. Examples: both &quot;250&quot; and &quot;250,25&quot; will work while &quot;250,,10&quot; will not. See below for details.">
                    <sanitizer invalid_char="">
                        <valid initial="string.digits"><add value="," /> </valid>
                    </sanitizer>
                </param>
            </when>
        </conditional>

        <conditional name="rg">
            <param name="rg_selector" type="select" label="Set read groups information?" help="Specifying read group information can greatly simplify your downstream analyses by allowing combining multiple datasets.">
                <option value="set">Set read groups (SAM/BAM specification)</option>
                <option value="set_picard">Set read groups (Picard style)</option>
                <option value="set_id_auto">Automatically assign ID</option>
                <option value="do_not_set" selected="True">Do not set</option>
            </param>
            <when value="set_picard">
                <conditional name="read_group_id_conditional">
            <param name="do_auto_name" type="boolean" label="Auto-assign" help="Use dataset name or collection information to automatically assign this value" checked="no" />
        <when value="true">
        </when>
        <when value="false">
            <param name="ID" type="text" value="" label="Read group identifier (ID)" help="This value must be unique among multiple samples in your experiment" optional="false">
            <validator type="empty_field" />
        </param>
    </when>
    </conditional>
    <conditional name="read_group_sm_conditional">
            <param name="do_auto_name" type="boolean" label="Auto-assign" help="Use dataset name or collection information to automatically assign this value" checked="no" />
        <when value="true">
        </when>
        <when value="false">
            <param name="ID" type="text" value="" label="Read group identifier (ID)" help="This value must be unique among multiple samples in your experiment" optional="false">
            <validator type="empty_field" />
        </param>
    </when>
    </conditional>
    <conditional name="read_group_lb_conditional">
            <param name="do_auto_name" type="boolean" label="Auto-assign" help="Use dataset name or collection information to automatically assign this value" checked="no" />
        <when value="true">
        </when>
        <when value="false">
            <param name="ID" type="text" value="" label="Read group identifier (ID)" help="This value must be unique among multiple samples in your experiment" optional="false">
            <validator type="empty_field" />
        </param>
    </when>
    </conditional>
    <param name="PL" type="select" label="Platform/technology used to produce the reads (PL)">
            <option value="CAPILLARY">CAPILLARY</option>
            <option value="LS454">LS454</option>
            <option selected="True" value="ILLUMINA">ILLUMINA</option>
            <option value="SOLID">SOLID</option>
            <option value="HELICOS">HELICOS</option>
            <option value="IONTORRENT">IONTORRENT</option>
            <option value="PACBIO">PACBIO</option>
        </param>
    <param name="PU" type="text" value="run" label="Platform unit (PU)" help="Unique identifier (e.g. flowcell-barcode.lane for Illumina or slide for SOLiD)" optional="False" />
    <param name="CN" type="text" label="Sequencing center that produced the read (CN)" />
    <param name="DS" type="text" label="Description (DS)" />
    <param name="PI" type="integer" optional="true" label="Predicted median insert size (PI)" />
    <param name="DT" type="text" label="Date that run was produced (DT)" help="ISO8601 format date or date/time, like YYYY-MM-DD" />
    </when>
            <when value="set">
                <conditional name="read_group_id_conditional">
            <param name="do_auto_name" type="boolean" label="Auto-assign" help="Use dataset name or collection information to automatically assign this value" checked="no" />
        <when value="true">
        </when>
        <when value="false">
            <param name="ID" type="text" value="" label="Read group identifier (ID)" help="This value must be unique among multiple samples in your experiment" optional="false">
            <validator type="empty_field" />
        </param>
    </when>
    </conditional>
    <conditional name="read_group_sm_conditional">
            <param name="do_auto_name" type="boolean" label="Auto-assign" help="Use dataset name or collection information to automatically assign this value" checked="no" />
        <when value="true">
        </when>
        <when value="false">
            <param name="ID" type="text" value="" label="Read group identifier (ID)" help="This value must be unique among multiple samples in your experiment" optional="false">
            <validator type="empty_field" />
        </param>
    </when>
    </conditional>
    <param name="PL" type="select" label="Platform/technology used to produce the reads (PL)">
            <option value="CAPILLARY">CAPILLARY</option>
            <option value="LS454">LS454</option>
            <option selected="True" value="ILLUMINA">ILLUMINA</option>
            <option value="SOLID">SOLID</option>
            <option value="HELICOS">HELICOS</option>
            <option value="IONTORRENT">IONTORRENT</option>
            <option value="PACBIO">PACBIO</option>
        </param>
    <conditional name="read_group_lb_conditional">
            <param name="do_auto_name" type="boolean" label="Auto-assign" help="Use dataset name or collection information to automatically assign this value" checked="no" />
        <when value="true">
        </when>
        <when value="false">
            <param name="ID" type="text" value="" label="Read group identifier (ID)" help="This value must be unique among multiple samples in your experiment" optional="false">
            <validator type="empty_field" />
        </param>
    </when>
    </conditional>
    <param name="CN" type="text" label="Sequencing center that produced the read (CN)" />
    <param name="DS" type="text" label="Description (DS)" />
    <param name="DT" type="text" label="Date that run was produced (DT)" help="ISO8601 format date or date/time, like YYYY-MM-DD" />
    <param name="FO" type="text" optional="true" label="Flow order (FO)" help="The array of nucleotide bases that correspond to the nucleotides used for each flow of each read. Multi-base flows are encoded in IUPAC format, and non-nucleotide flows by various other characters. Format: /\*|[ACMGRSVTWYHKDBN]+/">
          <validator type="regex" message="Invalid flow order">\*|[ACMGRSVTWYHKDBN]+$</validator>
        </param>
    <param name="KS" type="text" label="The array of nucleotide bases that correspond to the key sequence of each read (KS)" />
    <param name="PG" type="text" label="Programs used for processing the read group (PG)" />
    <param name="PI" type="integer" optional="true" label="Predicted median insert size (PI)" />
    <param name="PU" type="text" label="Platform unit (PU)" help="Unique identifier (e.g. flowcell-barcode.lane for Illumina or slide for SOLiD)" optional="True" />
    </when>
            <when value="set_id_auto">
            </when>
            <when value="do_not_set">
            </when>
        </conditional>
    <conditional name="analysis_type">
            <param name="analysis_type_selector" type="select" label="Select analysis mode">
                <option value="illumina">1.Simple Illumina mode</option>
                <option value="pacbio">2.PacBio mode (-x pacbio)</option>
                <option value="ont2d">3.Nanopore 2D-reads mode (-x ont2d)</option>
                <option value="intractg">4.Intra-species contigs mode (-x intractg)</option>
                <option value="full">5.Full list of options</option>
            </param>
            <when value="illumina">
                
            </when>
            <when value="pacbio">
                
            </when>
            <when value="ont2d">
                
            </when>
            <when value="intractg">
                
            </when>
            <when value="full">
                <conditional name="algorithmic_options">
                    <param name="algorithmic_options_selector" type="select" label="Set algorithmic options?" help="Sets -k, -w, -d, -r, -y, -c, -D, -W, -m, -S, -P, and -e options.">
                        <option value="set">Set</option>
                        <option value="do_not_set" selected="True">Do not set</option>
                    </param>
                    <when value="set">
                        <param name="k" type="integer" value="19" label="Minimum seed length" help="-k; default=19" />
                        <param name="w" type="integer" value="100" label="Band width for banded alignment" help="-w; default=100" />
                        <param name="d" type="integer" value="100" label="Off-diagonal X-dropoff" help="-d; default=100" />
                        <param name="r" type="float" value="1.5" label="Look for internal seeds inside a seed longer than -k * THIS VALUE" help="-r; default=1.5; This is a key heuristic parameter for tuning the performance. Larger value yields fewer seeds, which leads to faster alignment speed but lower accuracy" />
                        <param name="y" type="integer" value="20" label="Seed occurrence for the 3rd round seeding" help="-y; default=20" />
                        <param name="c" type="integer" value="500" label="Skip seeds with more than that many occurrences" help="-c; default=500" />
                        <param name="D" type="float" value="0.5" label="Drop chains shorter than this fraction of the longest overlapping chain" help="-D; default=0.5" />
                        <param name="W" type="integer" value="0" label="Discard a chain if seeded bases shorter than THIS VALUE" help="-W; default=0" />
                        <param name="m" type="integer" value="50" label="Perform at most this many rounds of mate rescues for each read" help="-m; default=50" />
                        <param name="S" type="boolean" truevalue="-S" falsevalue="" label="Skip mate rescue" help="-S" />
                        <param name="P" type="boolean" truevalue="-P" falsevalue="" label="Skip pairing; mate rescue performed unless -S also in use" help="-P" />
                        <param name="e" type="boolean" truevalue="-e" falsevalue="" label="Discard full-length exact matches" help="-e" />
                    </when>
                    <when value="do_not_set">
                        
                    </when>
                </conditional>

                <conditional name="scoring_options">
                    <param name="scoring_options_selector" type="select" label="Set scoring options?" help="Sets -A, -B, -O, -E, -L, and -U options.">
                        <option value="set">Set</option>
                        <option value="do_not_set" selected="True">Do not set</option>
                    </param>
                    <when value="set">
                        <param name="A" type="integer" value="1" label="Score for a sequence match" help="-A; scales options -T, -d, -B, -O, -E, -L, and -U unless overridden; default=1" />
                        <param name="B" type="integer" value="4" label="Penalty for a mismatch" help="-B; default=4" />
                        <param name="O" type="text" value="6,6" label="Gap open penalties for deletions and insertions" help="-O; default=6,6">
                            <sanitizer invalid_char="">
                                <valid initial="string.digits"><add value="," /> </valid>
                            </sanitizer>
                        </param>
                        <param name="E" type="text" value="1,1" label="Gap extension penalties; a gap of size k cost '-O + -E*k'. If two numbers are specified, the first is the penalty of extending a deletion and the second for extending an insertion" help="-E; default=1,1">
                            <sanitizer invalid_char="">
                                <valid initial="string.digits"><add value="," /> </valid>
                            </sanitizer>
                        </param>
                        <param name="L" type="text" value="5,5" label="Penalties for 5'-end and 3'-end clipping" help="-L; default=5,5; When performing Smith-Waterman extension, BWA-MEM keeps track of the best score reaching the end of query. If this score is larger than the best Smith-Waterman score minus the clipping penalty, clipping will not be applied. Note that in this case, the SAM AS tag reports the best Smith-Waterman score; clipping penalty is not deduced">
                            <sanitizer invalid_char="">
                                <valid initial="string.digits"><add value="," /> </valid>
                            </sanitizer>
                        </param>
                        <param name="U" type="integer" value="17" label="Penalty for an unpaired read pair" help="-U; default=17" />
                    </when>
                    <when value="do_not_set">
                        
                    </when>
                </conditional>

                <conditional name="io_options">
                    <param name="io_options_selector" type="select" label="Set input/output options" help="Sets -T, -h, -a, -C, -V, -Y, and -M options.">
                        <option value="set">Set</option>
                        <option value="do_not_set" selected="True">Do not set</option>
                    </param>
                    <when value="set">
                        <param name="five" argument="-5" type="boolean" truevalue="-5" falsevalue="" label="For split alignment, take alignment with smallest coordinate as primary" help="Useful for HiC data" />
                        <param argument="-q" type="boolean" truevalue="-q" falsevalue="" label="Don't lower MAPQ for split alignment" help="By default the MAPQ score of a supplementary alignment will be lowered to the primary alignment score." />
                        <param name="T" type="integer" value="30" label="Minimum score to output" help="-T; default=30" />
                        <param name="h" type="integer" value="5" label="If there are less than THIS VALUE hits with score &gt;80% of the max score, output them all in the XA tag" help="-h; default=5" />
                        <param name="a" type="boolean" truevalue="-a" falsevalue="" label="Output all alignments for single-ends or unpaired paired-ends" help="-a; These alignments will be flagged as secondary alignments" />
                        <param name="C" type="boolean" truevalue="-C" falsevalue="" label="Append FASTA/FASTQ comment to BAM output" help="-C" />
                        <param name="V" type="boolean" truevalue="-V" falsevalue="" label="Output the reference FASTA header in the XR tag" help="-C" />
                        <param name="Y" type="boolean" truevalue="-Y" falsevalue="" label="Use soft clipping for supplementary alignments" help="-Y; By default, BWA-MEM uses soft clipping for the primary alignment and hard clipping for supplementary alignments" />
                        <param name="M" type="boolean" truevalue="-M" falsevalue="" label="Mark shorter split hits of a chimeric alignment in the FLAG field as 'secondary alignment' instead of 'supplementary alignment'" help="-M; For Picard&lt;1.96 compatibility" />
                    </when>
                    <when value="do_not_set">
                        
                    </when>
                </conditional>
            </when>
        </conditional>
        <param name="output_sort" type="select" label="BAM sorting mode" help="The 'Not sorted' option can extend the run time of the tool significantly (cause it requires running on only a single thread).">
            <option value="coordinate" selected="True">Sort by chromosomal coordinates</option>
            <option value="name">Sort by read names  (i.e., the QNAME field) </option>
            <option value="unsorted">Not sorted (sorted as input)</option>
        </param>
    </inputs>

    <outputs>
        <data format="bam" name="bam_output" label="${tool.name} on ${on_string} (mapped reads in BAM format)">
            <actions>
            <conditional name="reference_source.reference_source_selector">
                <when value="cached">
                    <action type="metadata" name="dbkey">
                        <option type="from_data_table" name="bwa_mem_indexes" column="1" offset="0">
                <filter type="param_value" column="0" value="#" compare="startswith" keep="False" />
                <filter type="param_value" ref="reference_source.ref_file" column="0" />
            </option>
        </action>
                </when>
                <when value="history">
                    <action type="metadata" name="dbkey">
                        <option type="from_param" name="reference_source.ref_file" param_attribute="dbkey" />
                    </action>
                </when>
            </conditional>
        </actions>
    <change_format>
                <when input="output_sort" value="name" format="qname_sorted.bam" />
                <when input="output_sort" value="unsorted" format="qname_input_sorted.bam" />
            </change_format>
        </data>
    </outputs>

    <tests>
        <test>
            <param name="reference_source_selector" value="history" />
            <param name="ref_file" ftype="fasta" value="bwa-mem-mt-genome.fa" />
            <param name="fastq_input_selector" value="paired" />
            <param name="fastq_input1" ftype="fastqsanger" value="bwa-mem-fastq1.fq" />
            <param name="fastq_input2" ftype="fastqsanger" value="bwa-mem-fastq2.fq" />
            <param name="analysis_type_selector" value="illumina" />
            <output name="bam_output" ftype="bam" file="bwa-mem-test1.bam" lines_diff="2" />
        </test>
        <test>
            <param name="reference_source_selector" value="history" />
            <param name="ref_file" ftype="fasta" value="bwa-mem-mt-genome.fa" />
            <param name="fastq_input_selector" value="single" />
            <param name="fastq_input1" ftype="fastqsanger" value="bwa-mem-fasta1.fa" />
            <param name="analysis_type_selector" value="illumina" />
            <output name="bam_output" ftype="bam" file="bwa-mem-test1-fasta.bam" lines_diff="2" />
        </test>
        <test>
            <param name="reference_source_selector" value="history" />
            <param name="ref_file" ftype="fasta" value="bwa-mem-mt-genome.fa" />
            <param name="fastq_input_selector" value="paired" />
            <param name="fastq_input1" ftype="fastqsanger.gz" value="bwa-mem-fastq1.fq.gz" />
            <param name="fastq_input2" ftype="fastqsanger" value="bwa-mem-fastq2.fq" />
            <param name="analysis_type_selector" value="illumina" />
            <output name="bam_output" ftype="bam" file="bwa-mem-test1.bam" lines_diff="2" />
        </test>
        <test>
            <param name="reference_source_selector" value="history" />
            <param name="ref_file" ftype="fasta" value="bwa-mem-mt-genome.fa" />
            <param name="index_a" value="is" />
            <param name="fastq_input_selector" value="paired" />
            <param name="fastq_input1" ftype="fastqsanger" value="bwa-mem-fastq1.fq" />
            <param name="fastq_input2" ftype="fastqsanger" value="bwa-mem-fastq2.fq" />
            <param name="rg_selector" value="set" />
            <param name="ID" value="rg1" />
            <param name="PL" value="CAPILLARY" />
            <param name="LB" value="AARDVARK-1" />
            <param name="analysis_type_selector" value="illumina" />
            <output name="bam_output" ftype="bam" file="bwa-mem-test2.bam" lines_diff="2" />
        </test>
        <test>
            <param name="reference_source_selector" value="history" />
            <param name="ref_file" ftype="fasta" value="bwa-mem-mt-genome.fa" />
            <param name="fastq_input_selector" value="paired" />
            <param name="fastq_input1" ftype="fastqsanger" value="bwa-mem-fastq1.fq" />
            <param name="fastq_input2" ftype="fastqsanger" value="bwa-mem-fastq2.fq" />
            <param name="analysis_type_selector" value="illumina" />
            <param name="output_sort" value="unsorted" />
            <output name="bam_output" ftype="qname_input_sorted.bam" file="bwa-mem-test3.bam" lines_diff="2" />
        </test>
        <test>
            <param name="reference_source_selector" value="history" />
            <param name="ref_file" ftype="fasta" value="bwa-mem-mt-genome.fa" />
            <param name="fastq_input_selector" value="paired" />
            <param name="fastq_input1" ftype="fastqsanger" value="bwa-mem-fastq1.fq" />
            <param name="fastq_input2" ftype="fastqsanger" value="bwa-mem-fastq2.fq" />
            <param name="analysis_type_selector" value="illumina" />
            <param name="output_sort" value="name" />
            <output name="bam_output" ftype="qname_sorted.bam" file="bwa-mem-test4.bam" lines_diff="2" />
        </test>
    </tests>
    <help>
**What is does**

From http://arxiv.org/abs/1303.3997:

BWA-MEM is an alignment algorithm for aligning sequence reads or long query sequences against a large reference genome such as human.
It automatically chooses between local and end-to-end alignments, supports paired-end reads and performs chimeric alignment.
The algorithm is robust to sequencing errors and applicable to a wide range of sequence lengths from 70bp to a few megabases.

This Galaxy tool wraps bwa-mem module of bwa read mapping tool. The Galaxy implementation takes fastq files as input and produces output in BAM format, which can be further processed using various BAM utilities exiting in Galaxy (BAMTools, SAMTools, Picard).

-----

**Indices: Selecting reference genomes for BWA**

Galaxy wrapper for BWA allows you select between precomputed and user-defined indices for reference genomes using **Will you select a reference genome from your history or use a built-in index?** flag. This flag has two options:

  1. **Use a built-in genome index** - when selected (this is default), Galaxy provides the user with **Select reference genome index** dropdown. Genomes listed in this dropdown have been pre-indexed with bwa index utility and are ready to be mapped against.
  2. **Use a genome from the history and build index** - when selected, Galaxy provides the user with **Select reference genome sequence** dropdown. This dropdown is populated by all FASTA formatted files listed in your current history. If your genome of interest is uploaded into history it will be shown there. Selecting a genome from this dropdown will cause Galaxy to first transparently index it using `bwa index` command, and then run mapping with `bwa mem`.

If your genome of interest is not listed here you have two choices:

  1. Contact galaxy team using **Help-&gt;Support** link at the top of the interface and let us know that an index needs to be added
  2. Upload your genome of interest as a FASTA file to Galaxy history and selected **Use a genome from the history and build index** option.

-----

**Galaxy-specific option**

Galaxy allows four levels of control over bwa-mem options provided by **Select analysis mode** menu option. These are:

  1. *Simple Illumina mode*: The simplest possible bwa mem application in which it alignes single or paired-end data to reference using default parameters. It is equivalent to the following command: bwa mem &lt;reference index&gt; &lt;fastq dataset1&gt; [fastq dataset2]
  2. *PacBio mode*: The mode adjusted specifically for mapping of long PacBio subreads. Equivalent to the following command: bwa mem -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  &lt;reference index&gt; &lt;PacBio dataset in fastq format&gt;
  3. *Full list of options*: Allows access to all options through Galaxy interface.

  -----

**Bam sorting mode**

The generated bam files can be sorted according to three criteria: coordinates, names and input order.

In coordinate sorted mode the reads are sorted by coordinates. It means that the reads from the beginning of the first chromosome are first in the file. 

When sorted by read name, the file is sorted by the reference ID (i.e., the QNAME field). 

Finally, the *No sorted (sorted as input)* option yield a BAM file in which the records are sorted in an order corresponding to the order of the reads in the original input file. This option requires using a single thread to perform the conversion from SAM to BAM format, so the runtime is extended.



-----

.. class:: warningmark

**Read Groups are Important!**

One of the recommended best practices in NGS analysis is adding read group information to BAM files. You can do this directly in BWA interface using the
**Specify read group information?** widget. If you are not familiar with read groups you shold know that this is effectively a way to tag reads with an additional ID.
This allows you to combine BAM files from, for example, multiple BWA runs into a single dataset. This significantly simplifies downstream processing as
instead of dealing with multiple datasets you only have to handle only one. This is possible because the read group information allows you to identify
data from different experiments even if they are combined in one file. Many downstream analysis tools such as variant callers (e.g., FreeBayes or Naive Variant Caller
present in Galaxy) are aware of read groups and will automatically generate calls for each individual sample even if they are combined within a single file.

**Description of read groups fields**

(from GATK FAQ webpage):

.. csv-table::
   :header-rows: 1
    
    Tag,Importance,Definition,Meaning
    "ID","Required","Read group identifier. Each @RG line must have a unique ID. The value of ID is used in the RG tags of alignment records. Must be unique among all read groups in header section. Read group IDs may be modified when merging SAM files in order to handle collisions.","Ideally, this should be a globally unique identify across all sequencing data in the world, such as the Illumina flowcell + lane name and number.  Will be referenced by each read with the RG:Z field, allowing tools to determine the read group information associated with each read, including the sample from which the read came.  Also, a read group is effectively treated as a separate run of the NGS instrument in tools like base quality score recalibration (a GATK component) -- all reads within a read group are assumed to come from the same instrument run and to therefore share the same error model."
    "SM","Sample. Use pool name where a pool is being sequenced.","Required.  As important as ID.","The name of the sample sequenced in this read group.  GATK tools treat all read groups with the same SM value as containing sequencing data for the same sample.  Therefore it's critical that the SM field be correctly specified, especially when using multi-sample tools like the Unified Genotyper (a GATK component)."
    "PL","Platform/technology used to produce the read. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.","Important.  Not currently used in the GATK, but was in the past, and may return.  The only way to known the sequencing technology used to generate the sequencing data","It's a good idea to use this field."
    "LB","DNA preparation library identify","Essential for MarkDuplicates","MarkDuplicates uses the LB field to determine which read groups might contain molecular duplicates, in case the same DNA library was sequenced on multiple lanes."


**Example of Read Group usage**

Suppose we have a trio of samples: MOM, DAD, and KID.  Each has two DNA libraries prepared, one with 400 bp inserts and another with 200 bp inserts.  Each of these libraries is run on two lanes of an illumina hiseq, requiring 3 x 2 x 2 = 12 lanes of data.  When the data come off the sequencer, we would create 12 BAM files, with the following @RG fields in the header::

 Dad's data:
 @RG     ID:FLOWCELL1.LANE1      PL:illumina     LB:LIB-DAD-1 SM:DAD      PI:200
 @RG     ID:FLOWCELL1.LANE2      PL:illumina     LB:LIB-DAD-1 SM:DAD      PI:200
 @RG     ID:FLOWCELL1.LANE3      PL:illumina     LB:LIB-DAD-2 SM:DAD      PI:400
 @RG     ID:FLOWCELL1.LANE4      PL:illumina     LB:LIB-DAD-2 SM:DAD      PI:400
  
 Mom's data:
 @RG     ID:FLOWCELL1.LANE5      PL:illumina     LB:LIB-MOM-1 SM:MOM      PI:200
 @RG     ID:FLOWCELL1.LANE6      PL:illumina     LB:LIB-MOM-1 SM:MOM      PI:200
 @RG     ID:FLOWCELL1.LANE7      PL:illumina     LB:LIB-MOM-2 SM:MOM      PI:400
 @RG     ID:FLOWCELL1.LANE8      PL:illumina     LB:LIB-MOM-2 SM:MOM      PI:400
 
 Kid's data:
 @RG     ID:FLOWCELL2.LANE1      PL:illumina     LB:LIB-KID-1 SM:KID      PI:200
 @RG     ID:FLOWCELL2.LANE2      PL:illumina     LB:LIB-KID-1 SM:KID      PI:200
 @RG     ID:FLOWCELL2.LANE3      PL:illumina     LB:LIB-KID-2 SM:KID      PI:400
 @RG     ID:FLOWCELL2.LANE4      PL:illumina     LB:LIB-KID-2 SM:KID      PI:400

Note the hierarchical relationship between read groups (unique for each lane) to libraries (sequenced on two lanes) and samples (across four lanes, two lanes for each library).
    


-----

.. class:: infomark

**More info**

To obtain more information about BWA and ask questions use these resources:

  1. https://biostar.usegalaxy.org/
  2. https://www.biostars.org/
  3. https://github.com/lh3/bwa
  4. http://bio-bwa.sourceforge.net/

    
    </help>
    <citations>
        <citation type="doi">10.1093/bioinformatics/btp324</citation>
        <citation type="doi">10.1093/bioinformatics/btp698</citation>
        <citation type="bibtex">@misc{1303.3997,
            Author = {Heng Li},
            Title = {Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM},
            Year = {2013},
            Eprint = {arXiv:1303.3997},
            url = {http://arxiv.org/abs/1303.3997},
            }</citation>
    </citations>
</tool>