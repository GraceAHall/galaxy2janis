set -o pipefail;    
## Prepare HISAT2 index

#if $reference_genome.source == "history":
    ln -s '$reference_genome.history_item' genome.fa &&
    hisat2-build -p \${GALAXY_SLOTS:-1} genome.fa genome &&
    #set index_path = 'genome'
#else:
    #set index_path = $reference_genome.index.fields.path
#end if


## If using known splice sites

#if str($adv.spliced_options.spliced_options_selector) == "advanced" and str($adv.spliced_options.known_splice_gtf) != 'None':
    ln -s '${adv.spliced_options.known_splice_gtf}' splice_sites.gtf &&
    hisat2_extract_splice_sites.py splice_sites.gtf > splice_sites.txt &&
#end if


## Link in the input files, so HISAT2 can tell their type

#set compressed="False"
#set reads_are_fastq = True

#if str($library.type) == 'paired':
    #if $library.input_1.is_of_type("fastq.gz", "fastqsanger.gz"):
        #set read1 = "input_f.fastq.gz"
        #set compressed = "GZ"
    #elif $library.input_1.is_of_type("fastq.bz2", "fastqsanger.bz2"):
        #set read1 = "input_f.fastq.bz2"
        #set compressed = "BZ2"
    #elif $library.input_1.is_of_type('fasta'):
        #set reads_are_fastq = False
        #set read1 = "input_f.fasta"
    #else:
        #set read1 = "input_f.fastq"
    #end if
    ln -f -s '${library.input_1}' ${read1} &&

    #if $library.input_2.is_of_type("fastq.gz", "fastqsanger.gz"):
        #set read2 = "input_r.fastq.gz"
        #set compressed = "GZ"
    #elif $library.input_2.is_of_type("fastq.bz2", "fastqsanger.bz2"):
        #set read2 = "input_r.fastq.bz2"
        #set compressed = "BZ2"
    #elif $library.input_2.is_of_type('fasta'):
        #set read2 = "input_r.fasta"
    #else:
        #set read2 = "input_r.fastq"
    #end if
    ln -f -s '${library.input_2}' ${read2} &&

#elif str($library.type) == 'paired_collection':
    #if $library.input_1.forward.is_of_type("fastq.gz", "fastqsanger.gz"):
        #set read1 = "input_f.fastq.gz"
        #set compressed = "GZ"
    #elif $library.input_1.forward.is_of_type("fastq.bz2", "fastqsanger.bz2"):
        #set read1 = "input_f.fastq.bz2"
        #set compressed = "BZ2"
    #elif $library.input_1.forward.is_of_type('fasta'):
        #set reads_are_fastq = False
        #set read1 = "input_f.fasta"
    #else:
        #set read1 = "input_f.fastq"
    #end if
    ln -s '${library.input_1.forward}' ${read1} &&

    #if $library.input_1.reverse.is_of_type("fastq.gz", "fastqsanger.gz"):
        #set read2 = "input_r.fastq.gz"
        #set compressed = "GZ"
    #elif $library.input_1.reverse.is_of_type("fastq.bz2", "fastqsanger.bz2"):
        #set read2 = "input_r.fastq.bz2"
        #set compressed = "BZ2"
    #elif $library.input_1.reverse.is_of_type("fasta"):
        #set read2 = "input_r.fasta"
    #else:
        #set read2 = "input_r.fastq"
    #end if
    ln -s '${library.input_1.reverse}' ${read2} &&
#elif str( $library.type ) == "paired_interleaved":
    #if $library.input_1.is_of_type("fastq.gz", "fastqsanger.gz"):
        #set compressed = "GZ"
    #elif $library.input_1.is_of_type("fastq.bz2", "fastqsanger.bz2"):
        #set compressed = "BZ2"
    #elif $library.input_1.is_of_type('fasta'):
        #set reads_are_fastq = False
    #end if
    #set read1 = "input_f.fastq" if reads_are_fastq else "input_f.fasta"
    #set read2 = "input_r.fastq" if reads_are_fastq else "input_r.fasta"
    #if $library.input_1.is_of_type("fastq.bz2", "fastqsanger.bz2"):
        bzcat '${library.input_1}' | seqtk seq -1 /dev/stdin > $read1 &&
        bzcat '${library.input_1}' | seqtk seq -2 /dev/stdin > $read2 &&
    #else
        seqtk seq -1 '${library.input_1}' > $read1 &&
        seqtk seq -2 '${library.input_1}' > $read2 &&
    #end if
#else:
    #if $library.input_1.is_of_type("fastq.gz", "fastqsanger.gz"):
        #set read1 = "input_f.fastq.gz"
        #set compressed = "GZ"
    #elif $library.input_1.is_of_type("fastq.bz2", "fastqsanger.bz2"):
        #set read1 = "input_f.fastq.bz2"
        #set compressed = "BZ2"
    #elif $library.input_1.is_of_type('fasta'):
        #set reads_are_fastq = False
        #set read1 = "input_f.fasta"
    #else:
        #set read1 = "input_f.fastq"
    #end if
    ln -f -s '${library.input_1}' ${read1} &&
#end if


## Run HISAT2

hisat2

## number threads
-p \${GALAXY_SLOTS:-1}

## ref genome index path
-x '${index_path}'

## input reads are fasta?
#if not $reads_are_fastq:
    -f
#end if

## Input reads

#if str( $library.type ) == "single":

    -U '${read1}'

    #if str($adv.output_options.output_options_selector) == "advanced":
        #if str( $adv.output_options.unaligned_file ) == "true":
            #if $compressed == "GZ":
                --un-gz '$output_unaligned_reads_l'
            #elif $compressed == "BZ2":
                --un-bz2 '$output_unaligned_reads_l'
            #else:
                --un '$output_unaligned_reads_l'
            #end if
        #end if

        #if str( $adv.output_options.aligned_file ) == "true":
            #if $compressed == "GZ":
                --al-gz '$output_aligned_reads_l'
            #elif $compressed == "BZ2":
                --al-bz2 '$output_aligned_reads_l'
            #else:
                --al '$output_aligned_reads_l'
            #end if
        #end if
    #end if

#else:
    ##quotes are embedded in r1 and r2 variables, needed to allow use of <()
    #if str( $library.type ) == "paired_interleaved":
      -1 ${read1}
      -2 ${read2}
    #else:
      -1 '${read1}'
      -2 '${read2}'
    #end if
    #if str($adv.output_options.output_options_selector) == "advanced":
        #if str( $adv.output_options.unaligned_file ) == "true":
            #if $compressed == "GZ":
                --un-conc-gz '${output_unaligned_reads_l}'
            #elif $compressed == "BZ2":
                --un-conc-bz2 '${output_unaligned_reads_l}'
            #else:
                --un-conc '${output_unaligned_reads_l}'
            #end if
        #end if

        #if str( $adv.output_options.aligned_file ) == "true":
            #if $compressed == "GZ":
                --al-conc-gz '${output_aligned_reads_l}'
            #elif $compressed == "BZ2":
                --al-conc-bz2 '${output_aligned_reads_l}'
            #else:
                --al-conc '${output_aligned_reads_l}'
            #end if
        #end if
    #end if

    #if str($library.paired_options.paired_options_selector) == "advanced":
        ${library.paired_options.fr_rf_ff}
        ${library.paired_options.no_mixed}
        ${library.paired_options.no_discordant}
    #end if

#end if


## Specify strandedness of reads

#if str($library.rna_strandness):
    --rna-strandness ${library.rna_strandness}
#end if


## Input options

#if str($adv.input_options.input_options_selector) == "advanced":
    #if int( $adv.input_options.skip ) > 0:
        --skip ${adv.input_options.skip}
    #end if
    #if int( $adv.input_options.qupto ) > 0:
        --qupto ${adv.input_options.qupto}
    #end if
    --trim5 '${adv.input_options.trim5}'
    --trim3 '${adv.input_options.trim3}'
    ${adv.input_options.qv_encoding}
    ${adv.input_options.solexa_quals}
    ${adv.input_options.int_quals}
#end if


## Alignment options

#if str($adv.alignment_options.alignment_options_selector) == "advanced":
    --n-ceil ${adv.alignment_options.function_type},${adv.alignment_options.constant_term},${adv.alignment_options.coefficient}
    ${adv.alignment_options.ignore_quals}
    ${adv.alignment_options.skip_forward}
    ${adv.alignment_options.skip_reverse}
#end if


 ## Scoring options

#if str($adv.scoring_options.scoring_options_selector) == "advanced":
    --mp ${adv.scoring_options.max_mismatch},${adv.scoring_options.min_mismatch}
    ${adv.scoring_options.no_softclip}
    --np ${adv.scoring_options.ambiguous_penalty}
    --rdg ${adv.scoring_options.read_open_penalty},${adv.scoring_options.read_extend_penalty}
    --rfg ${adv.scoring_options.ref_open_penalty},${adv.scoring_options.ref_extend_penalty}
    --sp ${adv.scoring_options.soft_clip_penalty_max},${adv.scoring_options.soft_clip_penalty_min}
    --score-min ${adv.scoring_options.function_type},${adv.scoring_options.constant_term},${adv.scoring_options.coefficient}
#end if


## Spliced alignment options

#if str($adv.spliced_options.spliced_options_selector) == "advanced":
    --pen-cansplice ${adv.spliced_options.canonical_penalty}
    --pen-noncansplice ${adv.spliced_options.noncanonical_penalty}
    --pen-canintronlen ${adv.spliced_options.function_type},${adv.spliced_options.constant_term},${adv.spliced_options.coefficient}
    --pen-noncanintronlen ${adv.spliced_options.nc_function_type},${adv.spliced_options.nc_constant_term},${adv.spliced_options.nc_coefficient}
    #if str($adv.spliced_options.known_splice_gtf) != 'None':
        --known-splicesite-infile splice_sites.txt
    #end if
    ${adv.spliced_options.no_spliced_alignment_options.no_spliced_alignment}
    #if $adv.spliced_options.no_spliced_alignment_options.no_spliced_alignment == '--no-spliced-alignment'
        -I ${adv.spliced_options.no_spliced_alignment_options.minins}
        -X ${adv.spliced_options.no_spliced_alignment_options.maxins}
    #end if
    --min-intronlen ${adv.spliced_options.min_intron}
    --max-intronlen ${adv.spliced_options.max_intron}
    ${adv.spliced_options.tma}

    #if str($adv.spliced_options.novel_splicesite_outfile) == "true":
       --novel-splicesite-outfile '$novel_splicesite_output'
    #end if

    #if str($adv.spliced_options.notmplen):
        ${adv.spliced_options.notmplen}
    #end if
#end if


## Reporting options

#if str($adv.reporting_options.reporting_options_selector) == "advanced":
    #if str($adv.reporting_options.max_primary) != '':
        -k ${adv.reporting_options.max_primary}
    #end if
#end if


## SAM options

#if str($adv.sam_options.sam_options_selector) == "advanced":
    #if $adv.sam_options.no_unal:
        --no-unal
    #end if
    #if str($adv.sam_options.read_groups.rg_labels) == "Yes":
        --rg-id '$adv.sam_options.read_groups.rg_id'
        #if len('$adv.sam_options.read_groups.read_groups'):
            #for $i, $id in enumerate($adv.sam_options.read_groups.read_groups):
                --rg '$id.rg'
            #end for
        #end if
    #end if
    $adv.sam_options.chr_text
    #if $adv.sam_options.omit_sec_seq:
        --omit-sec-seq
    #end if
#end if

## Other options

#if str( $adv.other_options.other_options_selector ) == "advanced":
    ${adv.other_options.non_deterministic}
    --seed '${adv.other_options.seed}'
#end if


## Output Summary

#if str($sum.new_summary) == "true":
    --new-summary
#end if

#if str($sum.summary_file) == "true":
    --summary-file summary.txt
#end if

## Convert SAM output to sorted BAM
## using the two pipe stages has the following effect
## - hisat2 and sort run in parallel, during this time sort produces
##   presorted temporary files but does not produce output (hence
##   view does not run)
## - once hisat is finished sort will start to merge the temporary
##   files (which should be fast also on a single thread) gives the
##   sorted output to view which only compresses the files (now
##   using full parallelism again)

| samtools sort --no-PG -l 0 -T "\${TMPDIR:-.}" -O bam | samtools view --no-PG -O bam -@ \${GALAXY_SLOTS:-1} -o '${output_alignments}'

## Rename any output fastq files

#if $output_unaligned_reads_l and $output_unaligned_reads_r:
    #from os.path import splitext
    #set _unaligned_root, _unaligned_ext = splitext( str( $output_unaligned_reads_l ) )
    && mv '${ _unaligned_root }.1${_unaligned_ext}' '$output_unaligned_reads_l'
    && mv '${ _unaligned_root }.2${_unaligned_ext}' '$output_unaligned_reads_r'
#end if
#if $output_aligned_reads_l and $output_aligned_reads_r:
    #from os.path import splitext
    #set _aligned_root, _aligned_ext = splitext( str( $output_aligned_reads_l ) )
    && mv '${ _aligned_root }.1${_aligned_ext}' '$output_aligned_reads_l'
    && mv '${ _aligned_root }.2${_aligned_ext}' '$output_aligned_reads_r'
#end if